5. closure


클로저에 대한 정의는 아래와 같다.

```
A closure is the combination of a function and the lexical environment within which that function was declared.
```

> 클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경과의 조합이다.
> 

여기서 렉시컬 환경이란 함수가 선언됬을때 의 위치 이며 클로저는 자신이 생성된 환경을 기억하는 함수라고 생각하면 된다.

> 컴퓨터 언어에서 클로저는 일급 객체 함수의 개념을 이용하여 스코프에 묶인 변수를 바인딩 하기 위한 일종의 기술이다.
> 

```bash
lexical scope
상위 스코프에 대한 참조는 함수정의가 되는 시점에 정의된 환경에 의해 결정된다.
```

이제 클로저와 렉시컬환경의 관계에 대해 알아보겠다.

```jsx
var name = 'dump';

function a() {
  var name = 'jihee';
  var innerFunc = function () {
    console.log(name);
  }
  return innerFunc;
}
var b = a();
b() // 'jihee'
```

이 부분에서 함수를 실행했기때문에 a함수의 실행컨텍스트는 실행컨텍스트 스택에서 팝되어 제거된다.

```
var b = a();
```

그래서 a()의 name지역변수는 더이상 유효하지 않다.

- 어떻게 b를 호출하면 a함수의 지역변수 name를 참조할 수 있는 걸까?

```
b()// 'jihee'
```

**이처럼 외부함수(a)보다 중첩함수(innerFunc) 가 더 오래 유지되는 경우중첩함수는 이미 생명주기가 종료한 외부함수의 변수를 참조할 수 있는데 이러한 중첩함수를 클로저라 부른다.**

이게 가능한 이유는 **렉시컬스코프**랑 관련이 있다.

외부함수(a)가 호출되어 종료되었지만, 종료되면서 함수(innerFunc)를 반환했다. 이 innerFunc는 선언될 당시의 환경(상위스코프)을 기억한다.  a()의 렉시컬 환경을 innerFunc함수 **내부 [[Environment]]**에 저장한다. "**a()의 실행컨텍스트가 스택에서 제거 되어도 a()의 렉시컬 환경까지 소멸하는 것은 아니다."** innerFunc함수에서 a의 지역변수를 참조할 수 있는 이유다. 위 코드에서는 innerFunc함수가 종료되면 그제서야 a함수의 렉시컬 환경이 소멸된다.

****그럼 자바스크립트의 모든 함수는 상위스코프를 기억하므로 모든 함수가 클로저인가요?****

**상위 스코프의 식별자를 참조할때** 클로저라고 부른다. 

---

**클로저**

- 클로저 = 함수 + 함수를 둘러싼 환경(렉시컬 환경)

- 자바스크립트에서 클로저는 함수가 생성되는 시점에 생성

즉, 함수가 생성될 때 그 함수의 렉시컬 환경을 포섭하여, 실행될 때 함께 이용된다.

<aside>
💡 **클로저**

**일급 객체 함수(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술**이다. 기능상으로, **클로저는 함수를 저장한 레코드(record)**이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, **스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.** (위키백과)

</aside>

**클로저의 단점**

가비지콜렉터에 정리 대상이 되어야 할 것들이 메모리 상에 남아 있게 되므로, 남발 시 비효율적인 메모리 사용을 하게된다. 또한 퍼포먼스 측면에서도 단점이라 할 수도 있을 것 같다.

클로저는 변수에 접근하려 하면 해당 클로저로 생성한 스코프들을 탐색해서 찾아야 한다.

그러므로 적당히 적절한 때에 쓰는 것이 제일 바람직~
