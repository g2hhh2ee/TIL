프로젝트도 마무리 됐고 이제 다시 알고리즘 공부를 하려 하는데 다시 처음으로 돌아가 Big O 표기법에 대해 알아보려고 한다.

- Big O 표기법이 필요한 이유. 왜 고려해야 할까?
- Big O란?
- 시간 복잡도 및 공간 복잡도
- Big O를 사용한 서로 다른 알고리즘의 시간 복잡도 및 공간 복잡도 평가

## Big O 표기법이 필요한 이유


우리는 왜 Big O를 고려해야 할까? 어떤 코드가 제일 좋은지는 어떻게 알 수 있을까?

단순하게 생각해보자. 한 문제에 대한 서로 다른 솔루션이 있다고 가정하자. 어떤 솔루션이 더 나은지는 어떻게 알 수 있을까? 이때 필요한 게 Big O다.

Big O 표기법은 시간 및 공간 복잡도를 통해 어떤 솔루션이 가장 효율적인지 측정하는 방법이다.

Big O는 단순히 코드에 대해 “좋다” 또는 “나쁘다”라고 말하는 게 아니라 코드의 성능에 대해서 수치로 표현할 수 있다.

### 🤔 누가 신경써?

일단 작동하는 게 제일 중요한 거 아닌가요?

어떤 솔루션이 베스트인지가 왜 중요하죠?

이번 글을 작성하게 된 계기다. 우선 알고리즘 문제를 풀고! 그 다음에 성능을 고려해서 조금씩 고쳐나가면 되지 않을까? 라는 생각을 가지고 우선 문제를 해결하려고만 했다. 문제를 풀다보니 시간 초과로 에러가 발생하는 경우가 생겼고 그때 코드를 최적화했었는데 처음부터 고려하고 푸는 게 더 효율적이라는 생각이 들었다. 또 지금 당장은 괜찮을지 몰라도 더 많은 데이터를 다루게 되었을 때 문제가 생기지 않을까 하는 고민이 들었다. 예를 들어, 대량의 데이터 집합을 처리하는 대기업, 예를 들어 수억 개의 데이터 조각들이 있다고 하자. 한 알고리즘은 매번 실행될 때마다 다른 알고리즘에 비해 한 시간을 절약할 수 있다고 했을 때, 바로 이 시점에서 성능이 중요하다.

## Big O 표기법

코드의 확장성을 결정할 수 있도록 하며 이는 코드의 효율성을 측정하는 방법을 나타낸다. 코드의 성능을 정확히 어떻게 계산할 수 있을까? 런타임 속도? 복잡성/단순성? 컴퓨터의 차이에 관계없이 확장성을 다시 계산하는 방법은?

Big O로 입력 크기가 얼마나 큰지와 이것이 우리의 기능이나 알고리즘(알고리즘 효율성)을 얼마나 느리게 하는지를 측정할 수 있다. => 시공간 복잡도를 수학적으로 표시하는 대표적인 방법이다.

단, 코드의 실제 러닝 타임을 표시하는 것이 아니며, 입력 데이터 증가율에 따른 알고리즘의 성능을 (논리적으로) 예측하기 위해 사용한다. 빅오 표기법에는 다음 2가지 규칙이 있다.

1. **가장 높은 차수만 남긴다.**

   `O(n² + 3n) -> O(n²)`

2. **계수 및 상수는 고려하지 않는다.**

   `O(8n + 5) -> O(n)`

- O(1) (Constant)
  입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 나타낸다. 데이터가 얼마나 증가하든 성능에 영향을 거의 미치지 않는다.
- O(n) (Linear)
  입력 데이터의 크기에 비례해 처리 시간이 증가하는 알고리즘이다. 예를 들어 데이터가 10배가 되면, 처리 시간도 10배가 된다. 선형 탐색 알고리즘이 대표적이다.
  

![bigO](https://user-images.githubusercontent.com/57996351/171875505-d29d3f5a-73bd-4922-9e29-73d1197b4491.png)

  

## 객체의 Big O


객체란? \***\*순서가 없는 키 값 쌍.\*\***

무질서한 데이터 구조로 모든 내용이 키 값 쌍에 저장된다.

```jsx
let instructor = {
  firstName: "Kelly",
  isInstructor: true,
  favoriteNumbers: [1, 2, 3, 4],
};
```

### 객체를 사용할 때

- 순서가 필요하지 않을 때
- 빠른 접근, 삽입, 삭제가 필요할 때

그래서 순서는 없지만 다른 거의 모든 것이 빠르다.

우리가 “빠르다”라고 할 때, 이것은 데이터를 삽입, 삭제, 접근하는 일정한 시간을 가리킨다.

JavaScript는 일정한 시간 안에 (in constant time) 객체에 정보를 추가할 수 있고 새로운 것을 저장할 수 있고 마찬가지로 일정 시간 내에 업데이트할 수도 있다. 제거도 마찬가지.

객체의 모든 기본 조작은 매우 빨라서 순서가 없다.

객체의 시작과 끝은 없고 → 따라서 어디에 삽입하느냐는 중요하지 않다. (where가 없기 때문에!)

객체의 시작, 중간, 끝에 삽입할 수 없다. 그저 키를 사용해 추가하기만 하면 된다.

따라서 삽입, 삭제, 접근은 일정하다.

Insertion - **O(1)**

Removal - **O(1)**

Searching - **O(N)**

Access - **O(1)**

**When you don't need any ordering, objects are an excellent choice!**

## 배열의 Big O


Insertion - 때에 따라 다르다.

Removal - 때에 따라 다르다.

Searching - **O(N)**

Access - **O(1)**

## 기억할 것!


객체는 거의 모든 경우에 빠르고 순서가 없다.

배열은 순서가 필요할 때 좋다. 하지만 끝에서 추가 및 제거하고, 처음부터 추가 및 제거를 피하려면 써라. (cascade 효과 때문. 모든 것이 다시 인덱싱 되어야 한다.)
